import { getFileSystem, isBooted } from '../webcontainer';
import type { LocalFSAdapter } from './local-fs-adapter';
import type { SyncConfig, SyncPlan, SyncResult, SyncItem } from './sync-types';
import type { WorkspaceEventEmitter } from '../events';
import { SyncError } from './sync-types';

/**
 * Execute a synchronization plan.
 * 
 * Performs the side effects required to synchronize files based on the provided plan.
 * Reads content from LocalFS (for additions/modifications) and writes to WebContainer.
 * Handles event emission for progress tracking.
 * 
 * @param plan - The execution plan generated by SyncPlanner
 * @param adapter - Adapter for reading from LocalFS
 * @param config - Sync configuration (callbacks, etc.)
 * @param eventBus - Optional event bus for emitting workspace events
 * @returns result object with stats
 */
export async function executeSyncPlan(
    plan: SyncPlan,
    adapter: LocalFSAdapter,
    config: SyncConfig,
    eventBus?: WorkspaceEventEmitter
): Promise<SyncResult> {
    const startTime = performance.now();
    const result: SyncResult = {
        success: true,
        totalFiles: plan.stats.totalFiles,
        syncedFiles: 0,
        failedFiles: [],
        duration: 0,
    };

    // Emit start event
    eventBus?.emit('sync:started', {
        fileCount: plan.stats.totalFiles,
        direction: 'to-wc',
    });

    try {
        if (!isBooted()) {
            throw new SyncError(
                'WebContainer not booted',
                'WEBCONTAINER_NOT_BOOTED'
            );
        }

        const fs = getFileSystem();
        let processedCount = 0;

        // Process all items
        // Note: For now, we process sequentially to ensure reliability and correct event ordering.
        // Optimization: We could parallelize reads/writes or use `mount` for bulk adds if needed.
        for (const item of plan.items) {
            try {
                // Update progress
                const percentage = Math.round((processedCount / plan.items.length) * 100);
                eventBus?.emit('sync:progress', {
                    current: processedCount + 1,
                    total: plan.items.length,
                    currentFile: item.path
                });
                config.onProgress?.({
                    currentFile: item.path,
                    syncedFiles: result.syncedFiles,
                    totalFiles: result.totalFiles,
                    percentage
                });

                await processItem(item, adapter, fs);

                if (item.type === 'file') {
                    result.syncedFiles++;
                }

                processedCount++;
            } catch (error) {
                console.error(`[SyncExecutor] Failed to process ${item.path}:`, error);
                result.failedFiles.push(item.path);

                const syncError = new SyncError(
                    `Failed to sync ${item.path}`,
                    'FILE_WRITE_FAILED',
                    item.path,
                    error
                );

                // Emit error event but continue sync (partial failure)
                eventBus?.emit('sync:error', {
                    error: syncError,
                    file: item.path
                });
                config.onError?.(syncError);
            }
        }

        result.duration = Math.round(performance.now() - startTime);

        eventBus?.emit('sync:completed', {
            success: result.failedFiles.length === 0,
            timestamp: new Date(),
            filesProcessed: result.syncedFiles
        });

        // If there were failures but overall process finished, we still mark success as true
        // unless it was a catastrophic failure caught below.
        // However, SyncResult usually implies success if no exception was thrown?
        // Let's stick to: success = true if no critical errors. Failed files are listed.
        result.success = true; // Completed execution loop

    } catch (error) {
        result.success = false;
        result.duration = Math.round(performance.now() - startTime);

        const syncError = error instanceof SyncError ? error : new SyncError(
            `Sync execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            'SYNC_FAILED',
            undefined,
            error
        );

        eventBus?.emit('sync:error', { error: syncError });
        config.onError?.(syncError);

        throw syncError;
    } finally {
        config.onComplete?.(result);
    }

    return result;
}

/**
 * Process a single sync item (Side Effects)
 */
async function processItem(
    item: SyncItem,
    adapter: LocalFSAdapter,
    wcFs: any // WebContainer FileSystem
): Promise<void> {
    const { path, type, operation } = item;

    if (operation === 'delete') {
        try {
            await wcFs.rm(path, { recursive: type === 'directory' });
        } catch (e) {
            // Ignore if already deleted/not found
        }
        return;
    }

    if (type === 'directory') {
        if (operation === 'add') {
            await wcFs.mkdir(path, { recursive: true });
        }
        return;
    }

    // Handle File Operations (add/modify)
    if (operation === 'add' || operation === 'modify') {
        // Read from source (LocalFS)
        // Check if binary? For now assuming string or generic read.
        // LocalFSAdapter might return string or ArrayBuffer.
        // We'll trust readFile handles it or we need to check extension.
        // Assuming text for now as per previous SimpleFileSync.
        // Wait, typical LocalFSAdapter might return text by default.
        // Let's assume we read as UTF-8 for now.
        // Binary support might need `readBinaryFile` or options.
        // Looking at `sync-manager.ts` context, it didn't explicitly show `readFile` logic inside `buildFileSystemTree`, it hid it in `sync-operations`.

        try {
            const content = await adapter.readFile(path);

            // Ensure parent dir exists (just in case order wasn't perfect)
            const segments = path.split('/');
            if (segments.length > 1) {
                const parent = segments.slice(0, -1).join('/');
                try {
                    await wcFs.mkdir(parent, { recursive: true });
                } catch { }
            }

            await wcFs.writeFile(path, content);
        } catch (e) {
            throw e;
        }
    }
}
